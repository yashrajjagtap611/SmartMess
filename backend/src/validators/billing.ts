import { CreateBillingRequest, ProcessPaymentRequest } from '../interfaces/billing';

export interface ValidationResult {
  isValid: boolean;
  errors: string[];
}

export function validateBillingData(data: any): ValidationResult {
  const errors: string[] = [];

  // Required fields
  if (!data.userId) {
    errors.push('User ID is required');
  } else if (typeof data.userId !== 'string') {
    errors.push('User ID must be a string');
  }

  if (!data.messId) {
    errors.push('Mess ID is required');
  } else if (typeof data.messId !== 'string') {
    errors.push('Mess ID must be a string');
  }

  if (!data.membershipId) {
    errors.push('Membership ID is required');
  } else if (typeof data.membershipId !== 'string') {
    errors.push('Membership ID must be a string');
  }

  if (!data.planId) {
    errors.push('Plan ID is required');
  } else if (typeof data.planId !== 'string') {
    errors.push('Plan ID must be a string');
  }

  // Billing period validation
  if (!data.billingPeriod) {
    errors.push('Billing period is required');
  } else {
    if (!data.billingPeriod.startDate) {
      errors.push('Billing period start date is required');
    } else if (!(data.billingPeriod.startDate instanceof Date) && isNaN(Date.parse(data.billingPeriod.startDate))) {
      errors.push('Billing period start date must be a valid date');
    }

    if (!data.billingPeriod.endDate) {
      errors.push('Billing period end date is required');
    } else if (!(data.billingPeriod.endDate instanceof Date) && isNaN(Date.parse(data.billingPeriod.endDate))) {
      errors.push('Billing period end date must be a valid date');
    }

    if (data.billingPeriod.startDate && data.billingPeriod.endDate) {
      const startDate = new Date(data.billingPeriod.startDate);
      const endDate = new Date(data.billingPeriod.endDate);
      if (startDate >= endDate) {
        errors.push('Billing period start date must be before end date');
      }
    }

    if (!data.billingPeriod.period) {
      errors.push('Billing period is required');
    } else if (!['daily', 'weekly', '15days', 'monthly', '3months', '6months', 'yearly'].includes(data.billingPeriod.period)) {
      errors.push('Billing period must be one of: daily, weekly, 15days, monthly, 3months, 6months, yearly');
    }
  }

  // Adjustments validation
  if (data.adjustments && Array.isArray(data.adjustments)) {
    data.adjustments.forEach((adjustment: any, index: number) => {
      if (!adjustment.type) {
        errors.push(`Adjustment ${index + 1}: Type is required`);
      } else if (!['discount', 'penalty', 'leave_credit', 'late_fee', 'refund', 'bonus'].includes(adjustment.type)) {
        errors.push(`Adjustment ${index + 1}: Type must be one of: discount, penalty, leave_credit, late_fee, refund, bonus`);
      }

      if (typeof adjustment.amount !== 'number' || adjustment.amount < 0) {
        errors.push(`Adjustment ${index + 1}: Amount must be a non-negative number`);
      }

      if (!adjustment.reason) {
        errors.push(`Adjustment ${index + 1}: Reason is required`);
      } else if (typeof adjustment.reason !== 'string') {
        errors.push(`Adjustment ${index + 1}: Reason must be a string`);
      }

      if (!adjustment.appliedBy) {
        errors.push(`Adjustment ${index + 1}: Applied by is required`);
      } else if (typeof adjustment.appliedBy !== 'string') {
        errors.push(`Adjustment ${index + 1}: Applied by must be a string`);
      }
    });
  }

  // Metadata validation
  if (data.metadata) {
    if (data.metadata.generatedBy && !['system', 'admin', 'mess_owner'].includes(data.metadata.generatedBy)) {
      errors.push('Metadata generated by must be one of: system, admin, mess_owner');
    }

    if (data.metadata.tags && Array.isArray(data.metadata.tags)) {
      data.metadata.tags.forEach((tag: any, index: number) => {
        if (typeof tag !== 'string') {
          errors.push(`Metadata tag ${index + 1} must be a string`);
        }
      });
    }
  }

  return {
    isValid: errors.length === 0,
    errors
  };
}

// validateSubscriptionData removed

export function validatePaymentData(data: any): ValidationResult {
  const errors: string[] = [];

  // Required fields
  if (!data.amount) {
    errors.push('Amount is required');
  } else if (typeof data.amount !== 'number' || data.amount <= 0) {
    errors.push('Amount must be a positive number');
  }

  if (!data.messId) {
    errors.push('Mess ID is required');
  } else if (typeof data.messId !== 'string') {
    errors.push('Mess ID must be a string');
  }

  if (!data.description) {
    errors.push('Description is required');
  } else if (typeof data.description !== 'string') {
    errors.push('Description must be a string');
  }

  // Optional fields validation
  if (data.currency && typeof data.currency !== 'string') {
    errors.push('Currency must be a string');
  }

  if (data.billingId && typeof data.billingId !== 'string') {
    errors.push('Billing ID must be a string');
  }

  if (data.subscriptionId && typeof data.subscriptionId !== 'string') {
    errors.push('Subscription ID must be a string');
  }

  if (data.gatewayType && typeof data.gatewayType !== 'string') {
    errors.push('Gateway type must be a string');
  }

  // Customer info validation
  if (data.customerInfo) {
    if (data.customerInfo.name && typeof data.customerInfo.name !== 'string') {
      errors.push('Customer name must be a string');
    }

    if (data.customerInfo.email && typeof data.customerInfo.email !== 'string') {
      errors.push('Customer email must be a string');
    }

    if (data.customerInfo.phone && typeof data.customerInfo.phone !== 'string') {
      errors.push('Customer phone must be a string');
    }
  }

  // Metadata validation
  if (data.metadata) {
    if (data.metadata.ipAddress && typeof data.metadata.ipAddress !== 'string') {
      errors.push('IP address must be a string');
    }

    if (data.metadata.userAgent && typeof data.metadata.userAgent !== 'string') {
      errors.push('User agent must be a string');
    }

    if (data.metadata.location) {
      if (data.metadata.location.latitude && typeof data.metadata.location.latitude !== 'number') {
        errors.push('Location latitude must be a number');
      }

      if (data.metadata.location.longitude && typeof data.metadata.location.longitude !== 'number') {
        errors.push('Location longitude must be a number');
      }

      if (data.metadata.location.city && typeof data.metadata.location.city !== 'string') {
        errors.push('Location city must be a string');
      }

      if (data.metadata.location.state && typeof data.metadata.location.state !== 'string') {
        errors.push('Location state must be a string');
      }

      if (data.metadata.location.country && typeof data.metadata.location.country !== 'string') {
        errors.push('Location country must be a string');
      }
    }

    if (data.metadata.notes && typeof data.metadata.notes !== 'string') {
      errors.push('Metadata notes must be a string');
    }

    if (data.metadata.tags && Array.isArray(data.metadata.tags)) {
      data.metadata.tags.forEach((tag: any, index: number) => {
        if (typeof tag !== 'string') {
          errors.push(`Metadata tag ${index + 1} must be a string`);
        }
      });
    }
  }

  return {
    isValid: errors.length === 0,
    errors
  };
}

export function validateRefundData(data: any): ValidationResult {
  const errors: string[] = [];

  // Required fields
  if (!data.transactionId) {
    errors.push('Transaction ID is required');
  } else if (typeof data.transactionId !== 'string') {
    errors.push('Transaction ID must be a string');
  }

  if (!data.amount) {
    errors.push('Amount is required');
  } else if (typeof data.amount !== 'number' || data.amount <= 0) {
    errors.push('Amount must be a positive number');
  }

  if (!data.reason) {
    errors.push('Reason is required');
  } else if (typeof data.reason !== 'string') {
    errors.push('Reason must be a string');
  }

  if (!data.refundedBy) {
    errors.push('Refunded by is required');
  } else if (typeof data.refundedBy !== 'string') {
    errors.push('Refunded by must be a string');
  }

  // Optional fields validation
  if (data.metadata) {
    if (data.metadata.notes && typeof data.metadata.notes !== 'string') {
      errors.push('Metadata notes must be a string');
    }
  }

  return {
    isValid: errors.length === 0,
    errors
  };
}


